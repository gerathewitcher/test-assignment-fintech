"""init directory tables

Revision ID: bfff63daab90
Revises:
Create Date: 2026-02-22 18:30:58.113459

"""

from typing import Sequence, Union

import sqlalchemy as sa
from geoalchemy2 import Geography

from alembic import op

# revision identifiers, used by Alembic.
revision: str = "bfff63daab90"
down_revision: Union[str, Sequence[str], None] = None
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    """Upgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    op.execute(sa.text("CREATE EXTENSION IF NOT EXISTS pgcrypto"))
    op.execute(sa.text("CREATE EXTENSION IF NOT EXISTS postgis"))
    op.execute(sa.text("CREATE EXTENSION IF NOT EXISTS pg_trgm"))
    op.create_table(
        "activity",
        sa.Column(
            "id", sa.UUID(), server_default=sa.text("gen_random_uuid()"), nullable=False
        ),
        sa.Column("name", sa.VARCHAR(length=255), nullable=False),
        sa.Column("parent_id", sa.UUID(), nullable=True),
        sa.ForeignKeyConstraint(["parent_id"], ["activity.id"], ondelete="CASCADE"),
        sa.PrimaryKeyConstraint("id"),
    )
    op.create_index(
        op.f("ix_activity_parent_id"), "activity", ["parent_id"], unique=False
    )
    op.create_geospatial_table(
        "building",
        sa.Column(
            "id", sa.UUID(), server_default=sa.text("gen_random_uuid()"), nullable=False
        ),
        sa.Column("address", sa.VARCHAR(length=255), nullable=False),
        sa.Column(
            "location",
            Geography(
                geometry_type="POINT",
                srid=4326,
                dimension=2,
                spatial_index=False,
                from_text="ST_GeogFromText",
                name="geography",
                nullable=False,
            ),
            nullable=False,
        ),
        sa.Column(
            "created_at",
            sa.DateTime(timezone=True),
            server_default=sa.text("CURRENT_TIMESTAMP"),
            nullable=False,
        ),
        sa.PrimaryKeyConstraint("id"),
    )
    op.create_geospatial_index(
        "idx_building_location",
        "building",
        ["location"],
        unique=False,
        postgresql_using="gist",
        postgresql_ops={},
    )
    op.create_index(
        "ix_building_created_at_id", "building", ["created_at", "id"], unique=False
    )
    op.create_table(
        "organization",
        sa.Column(
            "id", sa.UUID(), server_default=sa.text("gen_random_uuid()"), nullable=False
        ),
        sa.Column("name", sa.VARCHAR(length=255), nullable=False),
        sa.Column("building_id", sa.UUID(), nullable=True),
        sa.Column(
            "created_at",
            sa.DateTime(timezone=True),
            server_default=sa.text("CURRENT_TIMESTAMP"),
            nullable=False,
        ),
        sa.ForeignKeyConstraint(["building_id"], ["building.id"], ondelete="SET NULL"),
        sa.PrimaryKeyConstraint("id"),
    )
    op.create_index(
        op.f("ix_organization_building_id"),
        "organization",
        ["building_id"],
        unique=False,
    )
    op.create_index(
        "ix_organization_created_at_id",
        "organization",
        ["created_at", "id"],
        unique=False,
    )
    op.create_index(
        "ix_organization_name_trgm",
        "organization",
        ["name"],
        unique=False,
        postgresql_using="gin",
        postgresql_ops={"name": "gin_trgm_ops"},
    )
    op.create_table(
        "organization_activity",
        sa.Column("organization_id", sa.UUID(), nullable=False),
        sa.Column("activity_id", sa.UUID(), nullable=False),
        sa.ForeignKeyConstraint(["activity_id"], ["activity.id"], ondelete="CASCADE"),
        sa.ForeignKeyConstraint(
            ["organization_id"], ["organization.id"], ondelete="CASCADE"
        ),
        sa.PrimaryKeyConstraint("organization_id", "activity_id"),
    )
    op.create_index(
        op.f("ix_organization_activity_activity_id"),
        "organization_activity",
        ["activity_id"],
        unique=False,
    )
    op.create_index(
        op.f("ix_organization_activity_organization_id"),
        "organization_activity",
        ["organization_id"],
        unique=False,
    )
    op.create_table(
        "organization_phone_number",
        sa.Column(
            "id", sa.UUID(), server_default=sa.text("gen_random_uuid()"), nullable=False
        ),
        sa.Column("organization_id", sa.UUID(), nullable=True),
        sa.Column("phone_number", sa.VARCHAR(length=255), nullable=False),
        sa.ForeignKeyConstraint(
            ["organization_id"], ["organization.id"], ondelete="SET NULL"
        ),
        sa.PrimaryKeyConstraint("id"),
    )
    create_activity_nesting_limit_trigger()
    # ### end Alembic commands ###


def downgrade() -> None:
    """Downgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    remove_activity_nesting_limit_trigger()
    op.drop_table("organization_phone_number")
    op.drop_index(
        op.f("ix_organization_activity_organization_id"),
        table_name="organization_activity",
    )
    op.drop_index(
        op.f("ix_organization_activity_activity_id"), table_name="organization_activity"
    )
    op.drop_table("organization_activity")
    op.drop_index(
        "ix_organization_name_trgm",
        table_name="organization",
        postgresql_using="gin",
        postgresql_ops={"name": "gin_trgm_ops"},
    )
    op.drop_index("ix_organization_created_at_id", table_name="organization")
    op.drop_index(op.f("ix_organization_building_id"), table_name="organization")
    op.drop_table("organization")
    op.drop_index("ix_building_created_at_id", table_name="building")
    op.drop_geospatial_index(
        "idx_building_location",
        table_name="building",
        postgresql_using="gist",
        column_name="location",
    )
    op.drop_geospatial_table("building")
    op.drop_index(op.f("ix_activity_parent_id"), table_name="activity")
    op.drop_table("activity")
    # ### end Alembic commands ###


def create_activity_nesting_limit_trigger():
    op.execute(
        """
        CREATE OR REPLACE FUNCTION check_activity_max_depth()
        RETURNS trigger
        LANGUAGE plpgsql
        AS $$
        DECLARE
            max_depth CONSTANT integer := 3;
            parent_chain_depth integer;
            subtree_depth integer := 1;
            has_cycle boolean := false;
            deepest_level integer;
        BEGIN
            IF NEW.parent_id IS NULL THEN
                RETURN NEW;
            END IF;

            IF TG_OP = 'UPDATE' AND NEW.parent_id IS NOT DISTINCT FROM OLD.parent_id THEN
                RETURN NEW;
            END IF;

            IF NEW.id IS NOT NULL AND NEW.parent_id = NEW.id THEN
                RAISE EXCEPTION 'Activity cannot be parent of itself';
            END IF;

            WITH RECURSIVE ancestors AS (
                SELECT a.id, a.parent_id, 1 AS depth
                FROM activity a
                WHERE a.id = NEW.parent_id
                UNION ALL
                SELECT a.id, a.parent_id, ancestors.depth + 1
                FROM activity a
                JOIN ancestors ON a.id = ancestors.parent_id
                WHERE ancestors.depth < max_depth + 10
            )
            SELECT COALESCE(MAX(depth), 0), COALESCE(BOOL_OR(id = NEW.id), false)
            INTO parent_chain_depth, has_cycle
            FROM ancestors;

            IF has_cycle THEN
                RAISE EXCEPTION 'Activity hierarchy cycle detected';
            END IF;

            IF TG_OP = 'UPDATE' THEN
                WITH RECURSIVE descendants AS (
                    SELECT a.id, 1 AS depth
                    FROM activity a
                    WHERE a.id = NEW.id
                    UNION ALL
                    SELECT a.id, descendants.depth + 1
                    FROM activity a
                    JOIN descendants ON a.parent_id = descendants.id
                )
                SELECT COALESCE(MAX(depth), 1) INTO subtree_depth
                FROM descendants;
            END IF;

            deepest_level := parent_chain_depth + subtree_depth;
            IF deepest_level > max_depth THEN
                RAISE EXCEPTION 'Activity max depth exceeded: % (allowed: %)',
                    deepest_level, max_depth;
            END IF;

            RETURN NEW;
        END;
        $$;
        """
    )

    op.execute(
        """
        CREATE TRIGGER trg_activity_max_depth
        BEFORE INSERT OR UPDATE OF parent_id
        ON activity
        FOR EACH ROW
        EXECUTE FUNCTION check_activity_max_depth();
        """
    )


def remove_activity_nesting_limit_trigger():
    op.execute("DROP TRIGGER IF EXISTS trg_activity_max_depth ON activity;")
    op.execute("DROP FUNCTION IF EXISTS check_activity_max_depth();")
